# Copilot Instructions - Family Games Project

## Información General del Proyecto

Este es un proyecto de **juegos familiares multijugador** que consiste en una aplicación móvil React Native con Expo Router y un servidor Node.js con Express y Socket.IO. **Arquitectura modular diseñada para múltiples juegos**.

### Arquitectura

- **Frontend**: React Native + Expo Router + Socket.IO Client
- **Backend**: Node.js + Express + Socket.IO + Prisma + MySQL
- **Base de Datos**: MySQL con Prisma ORM
- **Comunicación**: WebSockets (Socket.IO) para tiempo real
- **Estado**: Zustand para gestión de estado global
- **Navegación**: Expo Router (file-based routing)
- **Patrón**: **Modular Multi-Game Architecture** con lógica compartida y específica separada

### Principios de Diseño

- **Separación de responsabilidades**: Lógica compartida vs específica de cada juego
- **Escalabilidad**: Fácil agregar nuevos juegos sin afectar existentes
- **Reutilización**: Componentes, hooks y servicios reutilizables
- **Mantenibilidad**: Código organizado en módulos independientes

## Estructura del Proyecto

### Frontend (Mobile App - React Native) - Arquitectura Modular

```
frontend/
├── app/                        # 📱 RUTAS (Expo Router)
│   ├── _layout.js             # Layout principal
│   ├── index.js               # Pantalla inicial
│   ├── auth/                  # 🔐 AUTENTICACIÓN
│   │   ├── login.js           # Login/registro
│   │   └── profile.js         # Perfil de usuario
│   ├── lobby/                 # 🏠 LOBBY GENERAL
│   │   ├── index.js           # Selección de juego
│   │   ├── rooms.js           # Lista de salas
│   │   └── leaderboard.js     # Rankings generales
│   └── games/                 # 🎮 JUEGOS ESPECÍFICOS
│       ├── _layout.js         # Layout para juegos
│       ├── bingo/             # Juego de bingo
│       ├── cards/             # 🃏 JUEGOS DE CARTAS (futuro)
│       └── puzzle/            # 🧩 ROMPECABEZAS (futuro)
├── src/
│   ├── shared/                # 🔄 LÓGICA COMPARTIDA
│   │   ├── socket/            # Cliente Socket.IO y eventos base
│   │   ├── components/        # Componentes reutilizables (UI, game, chat, lobby)
│   │   ├── hooks/             # Hooks compartidos (useSocket, useAuth, useRoom)
│   │   ├── services/          # Servicios (API, storage, avatarCache, stats)
│   │   ├── store/             # Estado global Zustand (auth, room, game, ui)
│   │   └── utils/             # Utilidades compartidas
│   └── games/                 # 🎮 LÓGICA ESPECÍFICA DE JUEGOS
│       ├── gameInterface.js   # Interface base para juegos
│       └── bingo/             # Implementación específica del bingo
└── assets/                    # Recursos organizados por juego
```

### Backend (Server - Node.js) - Arquitectura Modular

```
backend/
├── server/
│   ├── index.js               # Servidor principal (inicialización)
│   ├── app.js                 # Configuración Express
│   ├── socketHandler.js       # Handler principal Socket.IO
│   ├── core/                  # 🔧 LÓGICA COMPARTIDA
│   │   ├── roomManager.js     # Gestión de salas genérica
│   │   ├── playerManager.js   # Gestión de jugadores
│   │   ├── gameRegistry.js    # Registro de juegos disponibles
│   │   └── socketEvents.js    # Eventos socket compartidos
│   ├── shared/                # 🔄 SERVICIOS COMPARTIDOS
│   │   ├── services/          # statsService, avatarService, chatService
│   │   ├── middleware/        # auth, validation, compression
│   │   └── utils/             # logger, constants, helpers
│   └── games/                 # 🎮 JUEGOS ESPECÍFICOS
│       ├── gameInterface.js   # Interface base para juegos
│       ├── bingo/             # Implementación completa del bingo
│       ├── cards/             # 🃏 JUEGOS DE CARTAS (futuro)
│       └── puzzle/            # 🧩 ROMPECABEZAS (futuro)
├── prisma/                    # Schema actualizado para múltiples juegos
└── config/                    # Configuración modular
```

## Tecnologías y Dependencias Principales

### Frontend

- **React Native**: 0.79.5
- **Expo**: ^53.0.0
- **Expo Router**: ~5.1.5 (file-based routing)
- **Socket.IO Client**: ^4.7.5
- **Zustand**: ^5.0.8 (estado global)
- **Expo Audio**: ^0.4.8 (sonidos del juego)
- **AsyncStorage**: 2.1.2 (persistencia local)
- **Expo Image Picker**: ~16.1.4 (avatares)
- **Fuentes**: Montserrat, Mukta

### Backend

- **Node.js** + **Express**: ^4.18.2
- **Socket.IO**: ^4.7.5
- **Prisma**: ^6.15.0 (ORM)
- **MySQL**: Base de datos
- **Sharp**: ^0.34.3 (procesamiento imágenes)
- **Nanoid**: ^5.0.7 (IDs únicos)
- **CORS**: ^2.8.5

## Patrones y Convenciones

### Arquitectura General
1. **Separación Modular**: Lógica compartida en `/shared/` y `/core/`, específica en `/games/`
2. **Interface Pattern**: Todos los juegos implementan `GameInterface` base
3. **Registry Pattern**: Juegos registrados en `gameRegistry.js` con metadatos
4. **Factory Pattern**: Creación de instancias de juegos mediante registry
5. **Observer Pattern**: Eventos Socket.IO para comunicación tiempo real

### Frontend
1. **Navegación**: Expo Router con estructura de archivos modular
2. **Componentes**: Funcionales con hooks, separados por responsabilidad
3. **Estado Global**: Zustand stores modulares (auth, room, game, ui)
4. **Socket Events**: Centralizados en `/shared/socket/` con eventos base y específicos
5. **Estilos**: StyleSheet consistente, tema centralizado
6. **Assets**: Organizados por juego en subcarpetas

### Backend
1. **Modular Architecture**: Separación clara entre lógica compartida y específica
2. **Game Interface**: Todos los juegos extienden clase base `GameInterface`
3. **Room Management**: Gestión de salas genérica reutilizable para todos los juegos
4. **Socket Events**: Eventos base compartidos + eventos específicos por juego
5. **Validation**: Validaciones genéricas + específicas por juego
6. **Database**: Schema normalizado para múltiples juegos
7. **Error Handling**: Logging centralizado con contexto por módulo

### Comunicación entre Módulos
1. **Dependency Injection**: Servicios inyectados en lugar de imports directos
2. **Event-Driven**: Comunicación via eventos para desacoplamiento
3. **Interface Contracts**: Contratos claros entre módulos compartidos y específicos

### Comunicación Socket.IO

#### Eventos Principales del Cliente

- `listRooms`: Listar salas disponibles
- `createRoom`: Crear nueva sala
- `joinRoom`: Unirse a sala
- `leaveRoom`: Salir de sala
- `startGame`: Iniciar partida (solo host)
- `claim`: Reclamar figura en bingo
- `sendChatMessage`: Enviar mensaje de chat
- `getStats`: Obtener estadísticas
- `updateProfile`: Actualizar perfil de usuario

#### Eventos del Servidor

- `rooms`: Lista de salas actualizada
- `state`: Estado de la sala actualizado
- `ball`: Nueva bola cantada
- `announcement`: Anuncio de figura completada
- `gameOver`: Fin de partida
- `chatMessage`: Mensaje de chat recibido

## Flujo de Juego (Bingo)

1. **Login**: Usuario ingresa nombre y selecciona avatar
2. **Lobby**: Lista de salas, crear nueva o unirse a existente
3. **Configuración**: Host configura cartones por jugador (1-4)
4. **Inicio**: Host inicia partida, se generan cartones
5. **Juego**: Sorteo automático con velocidades configurables
6. **Validación**: Server valida figuras reclamadas
7. **Anuncios**: Sistema de anuncios individuales con pausa
8. **Fin**: Cartón lleno gana, estadísticas actualizadas

### Figuras de Bingo

- `corners`: Cuatro esquinas
- `row`: Fila completa
- `column`: Columna completa
- `diagonal`: Diagonal completa
- `border`: Borde del cartón
- `full`: Cartón completo (ganador)

### Base de Datos (Prisma Schema) - Multi-Game Support

### Modelos Principales
```prisma
// Metadatos de juegos
model Game {
  gameKey     String   @id
  name        String
  description String?
  minPlayers  Int
  maxPlayers  Int
  isActive    Boolean  @default(true)
  
  GameSessions GameSession[]
  PlayerGameStats PlayerGameStats[]
}

// Sesiones de juego para tracking
model GameSession {
  id          String   @id @default(cuid())
  gameKey     String
  roomId      String
  startedAt   DateTime @default(now())
  endedAt     DateTime?
  winnerId    String?
  config      Json     // Configuración específica del juego
  
  Game        Game     @relation(fields: [gameKey], references: [gameKey])
  GameMoves   GameMove[]
}

// Movimientos individuales en partidas
model GameMove {
  id            String   @id @default(cuid())
  sessionId     String
  playerId      String
  moveData      Json     // Datos específicos del movimiento
  timestamp     DateTime @default(now())
  
  GameSession   GameSession @relation(fields: [sessionId], references: [id])
}

// Jugadores con soporte para múltiples juegos
model Player {
  username        String   @id
  name            String?
  avatarUrl       String?  @db.LongText
  avatarId        String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @default(now())
  PlayerGameStats PlayerGameStats[]
}

// Estadísticas por jugador y juego
model PlayerGameStats {
  playerUsername String
  gameKey        String
  points         Int    @default(0)
  totalGames     Int    @default(0)
  wins           Int    @default(0)
  
  Player         Player @relation(fields: [playerUsername], references: [username])
  Game           Game   @relation(fields: [gameKey], references: [gameKey])
  
  @@unique([playerUsername, gameKey])
}
```

## Estado Global (Zustand) - Arquitectura Modular

### Stores Compartidos
- `authStore.js`: Estado de autenticación y perfil de usuario
- `roomStore.js`: Estado de salas y lobby general  
- `gameStore.js`: Estado base común a todos los juegos
- `uiStore.js`: Estado de interfaz de usuario global
- `chatStore.js`: Estado del sistema de chat

### Stores Específicos por Juego
- `games/bingo/store/bingoStore.js`: Estado específico del bingo
- `games/bingo/store/bingoUiStore.js`: UI específica del bingo
- `games/bingo/store/animationStore.js`: Animaciones del bingo
- `games/cards/store/cardGameStore.js`: Estado de juegos de cartas (futuro)

### Pattern de Stores
```javascript
// Ejemplo de store base
const useGameStore = create((set, get) => ({
  // Estado compartido por todos los juegos
  currentGame: null,
  isInGame: false,
  gameConfig: {},
  
  // Acciones compartidas
  setCurrentGame: (gameKey) => set({ currentGame: gameKey }),
  resetGameState: () => set({ currentGame: null, isInGame: false })
}));

// Stores específicos extienden o componen con el base
const useBingoStore = create((set, get) => ({
  // Estado específico del bingo
  cards: [],
  drawnNumbers: [],
  figuresClaimed: {},
  
  // Acciones específicas del bingo
  markNumber: (cardIndex, number) => { /* lógica específica */ }
}));
```

## Funcionalidades Especiales

### Sistema de Avatares

- Compresión automática a ~50KB
- Caché eficiente por avatarId
- Sincronización entre dispositivos
- Soporte batch para múltiples avatares

### Chat en Tiempo Real

- Mensajes por sala
- Integrado con Socket.IO
- UI con toasts y panel lateral

### Sistema de Estadísticas

- Puntuación por figuras completadas
- Leaderboard global
- Estadísticas por jugador
- Persistencia en MySQL

### Optimizaciones

- Compresión de imágenes server-side
- Caché de avatares cliente-side
- Limpieza automática de salas vacías
- Reconexión automática de sockets

## Comandos Útiles

### Frontend

```bash
cd frontend
npm start                    # Desarrollo con Expo
npm run android             # Ejecutar en Android
npx eas update --branch preview-apk  # Actualización OTA
```

### Backend

```bash
cd backend
npm run dev                 # Desarrollo con nodemon
npm start                   # Producción
npx prisma migrate dev      # Migración BD
npx prisma studio          # GUI base de datos
```

## URLs y Configuración

### Servidor

- **Desarrollo**: localhost:4000
- **Producción**: https://familygames.duckdns.org
- **Railway**: https://family-games-backend-production.up.railway.app

### Variables de Entorno

- `DATABASE_URL`: Conexión MySQL
- `PORT`: Puerto del servidor (default: 4000)
- `CORS_ORIGIN`: Orígenes permitidos
- `HOST`: Host del servidor (default: 0.0.0.0)

## Consideraciones de Desarrollo

### Arquitectura Modular
1. **Separación de Responsabilidades**: Lógica compartida vs específica de juegos
2. **Extensibilidad**: Fácil agregar nuevos juegos implementando `GameInterface`
3. **Reutilización**: Componentes, hooks y servicios reutilizables entre juegos
4. **Mantenibilidad**: Código organizado en módulos independientes
5. **Testing**: Testeo independiente por módulos y juegos

### Comunicación y Estado
1. **Tiempo Real**: Socket.IO para sincronización de estado crítico
2. **Validación**: Doble validación (client + server) para jugadas
3. **Persistencia**: AsyncStorage para datos locales, MySQL para estadísticas
4. **Estado Global**: Stores modulares para evitar acoplamiento

### Performance y Escalabilidad
1. **Lazy Loading**: Carga bajo demanda de recursos específicos por juego
2. **Caché Inteligente**: Sistema de caché por módulos y recursos
3. **Room Management**: Arquitectura de salas escalable para múltiples juegos
4. **Resource Optimization**: Assets y código organizados por juego

### Patrones de Expansión
1. **Game Registry**: Registro centralizado de juegos disponibles
2. **Factory Pattern**: Creación de instancias de juegos dinámicamente
3. **Plugin Architecture**: Nuevos juegos como "plugins" independientes
4. **Configuration**: Configuración específica por juego en archivos separados

### Mejores Prácticas
1. **Interface Consistency**: Todos los juegos implementan interfaces estándar
2. **Error Boundaries**: Errores de un juego no afectan otros
3. **Resource Isolation**: Assets y dependencias aisladas por juego
4. **Documentation**: Documentación específica por módulo y juego

## Debugging y Logs

- Console.log para eventos Socket.IO
- Error tracking en try-catch blocks
- Performance logging para compresión de imágenes
- Connection status monitoring

---

**Nota**: Este proyecto utiliza una **arquitectura modular multi-juego** optimizada para dispositivos móviles con Expo, comunicación WebSocket para experiencia multijugador fluida, y base de datos MySQL para persistencia de estadísticas. La arquitectura está diseñada para **escalabilidad horizontal** permitiendo agregar nuevos juegos fácilmente sin afectar la funcionalidad existente.

## 📋 Recursos Adicionales

- **Plan de Refactorización**: Ver `REFACTORING_PLAN.md` para detalles completos de migración
- **Game Interface**: Documentación de interfaces base para nuevos juegos
- **API Documentation**: Eventos Socket.IO compartidos y específicos por juego
